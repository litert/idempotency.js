/**
 * Copyright 2025 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The type of idempotency records stored in the storage.
 */
export type IStoredRecord = IRecord<string | Buffer, string | Buffer>;

/**
 * The adapter interface for storage operations.
 *
 * Remember that this interface does not requires the deletion of records, as
 * the logics of cleaning up old records is up to the implementation of the
 * storage adapter.
 */
export interface IStorageAdapter {

    /**
     * Create a new idempotency record in the storage.
     *
     * This method must be atomic, and it should not allow overwriting an
     * existing record.
     *
     * @param data  The idempotency record to create.
     *
     * @returns A promise that resolves to true if the record was created
     *          successfully, false if it already exists.
     */
    create(data: IStoredRecord): Promise<boolean>;

    /**
     * Retrieve an idempotency record by its key from the storage.
     *
     * @param key   The unique key for this operation, used to ensure idempotency.
     */
    get(key: string): Promise<IStoredRecord | null>;

    /**
     * Update the idempotency record in the storage, from PENDING to SUCCESS or
     * FAILED.
     *
     * @param data The idempotency record to update.
     */
    update(data: IStoredRecord): Promise<void>;
}

/**
 * The status of an idempotency record.
 */
export enum EStatus {

    /**
     * The operation is still pending, and the result is not yet available.
     */
    PENDING,

    /**
     * The operation was successful, and the success result is available.
     */
    SUCCESS,

    /**
     * The operation failed, and the failure result is available.
     */
    FAILED,
}

/**
 * The idempotency record interface.
 */
export interface IRecord<TData, TError> {

    /**
     * The key that uniquely identifies this idempotency record.
     *
     * This is typically generated by the requestor and used to ensure idempotency.
     */
    key: string;

    /**
     * The status of the idempotency record.
     */
    status: EStatus;

    /**
     * The result of the operation.
     * When the status is SUCCESS, this will contain the successful result.
     * When the status is FAILED, this will contain the error that caused the
     * operation to fail.
     * If the status is PENDING, this does not exist.
     */
    result?: TData | TError;
}

/**
 * The serializer interface for idempotency results, whatever it is a success or failure.
 */
export interface ISerializer<T> {

    /**
     * Serialize data to a string or Buffer.
     *
     * @param data The data to serialize.
     */
    serialize(data: T): string | Buffer;

    /**
     * Deserialize data back to the original type.
     *
     * @param data  The serialized data to deserialize.
     */
    deserialize(data: string | Buffer): T;
}

/**
 * The signature of the callbacks used to wait for the completion of an operation.
 */
export interface IWaitCallback<TData, TError> {

    /**
     * The signature of the callbacks used to wait for the completion of an operation.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     * @param manager The manager object used to manage idempotency records.
     *
     * @returns A promise that resolves to the completed idempotency record.
     */
    // eslint-disable-next-line @typescript-eslint/prefer-function-type
    (
        key: string,
        manager: IManager<TData, TError>,
    ): Promise<TData>;
}

/**
 * The options for the idempotency manager.
 */
export interface IManagerOptions<TData, TError = Error> {

    /**
     * The adapter used for storage operations
     */
    storageAdapter: IStorageAdapter;

    /**
     * Serializer for successful results.
     *
     * @default DefaultSuccessSerializer
     */
    successSerializer?: ISerializer<TData>;

    /**
     * Serializer for failure results.
     *
     * @default DefaultFailureSerializer
     */
    failureSerializer?: ISerializer<TError>;

    /**
     * The callback to wait for the completion of an operation, if an idempotency record is pending.
     *
     * You can implement this to handle cases where you want to create a custom waiting mechanism.
     * Or just throw an error if you do not want to wait, enforcing the requester to retry.
     */
    waitCallback?: IWaitCallback<TData, TError>;
}

/**
 * The manager interface for idempotency records.
 */
export interface IManager<TData, TError = Error> {

    /**
     * Retrieve an idempotency record by its key.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     *
     * @return A promise that resolves to the idempotency record, or null if it does not exist.
     */
    get(key: string): Promise<IRecord<TData, TError> | null>;

    /**
     * Initiate a new idempotency record.
     *
     * @param key  The unique key for this operation, used to ensure idempotency.
     *
     * @returns A promise that resolves to true if the record was created, false if it already exists.
     */
    initiate(key: string): Promise<boolean>;

    /**
     * When an operation is successful, this method should be called to mark the operation as successful,
     * and save the result of the operation into the idempotency record.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     * @param result The result of the successful operation.
     */
    success(key: string, result: TData): Promise<void>;

    /**
     * When an operation fails, this method should be called to mark the operation as failed,
     * and save the error into the idempotency record.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     * @param error The error that caused the operation to fail.
     */
    fail(key: string, error: TError): Promise<void>;

    /**
     * Wait for an idempotency record to complete.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     *
     * @returns A promise that resolves to the completed result of the operation.
     *
     * @throws {E_WAIT_TIMEOUT} If the operation does not complete within the specified timeout.
     * @throws {E_STORAGE_FAILED} If there is a failure in the storage operation.
     */
    wait(key: string): Promise<TData>;
}

/**
 * The signature of the operation callback needs to be wrapped by the executor.
 */
export type IOperationCallback<TArgs extends unknown[], TResult> = (...args: TArgs) => Promise<TResult> | TResult;

/**
 * The signature of the function to check if a failure result should be stored.
 */
export type ICheckFailureStorable<TError> = (result: TError) => boolean;

/**
 * The options for the executors with idempotency protection.
 */
export interface IExecutorOptions<TArgs extends unknown[], TResult, TError = Error> {

    /**
     * The storage adapter for managing idempotency records
     */
    manager: IManager<TResult, TError>;

    /**
     * The actual operation to be executed with idempotency protection
     */
    operation: IOperationCallback<TArgs, TResult>;

    /**
     * An optional function to determine if a failure result should be stored.
     *
     * @param result    The result of the operation, which can be either a successful result or an error.
     *
     * @returns  `true` if the failure result should be stored, `false` otherwise.
     *
     * @default () => true // Store all failure results by default
     */
    isFailureStorable?: ICheckFailureStorable<TError>;
}

/**
 * The executor providing idempotency protection for operations.
 */
export interface IExecutor<TArgs extends unknown[], TResult> {

    /**
     * Execute an operation with idempotency protection.
     *
     * @param key The unique key for this operation, used to ensure idempotency.
     * @param args The arguments to pass to the operation.
     */
    execute(key: string, ...args: TArgs): Promise<TResult>;
}
